La base de donnée \href{https://postgis.net/}{PostGIS}\footnote{https://postgis.net/} que j'utilise se distingue par deux catégories de tables différentes. Premièrement, il y a les tables qui on été générées par l'import de données OSM. Ces tables contiennent les informations des éléments OSM tels que les bâtiments, les routes, les rivières, etc. Deuxièmement, il y a les tables qui sont générées par mon application qui stockeront les tuiles 3D ainsi que les Subtrees pour éviter de les re-générer à chaque fois car cela peut prendre plusieurs heures si le dataset est grand.

Pour accéder aux données de ces tables, j'utilise la librairie java \texttt{javax.sql.DataSource} qui me permet de me connecter à la base de données.

\subsection{Données OSM}

Dans les données OSM, les parties qui nous intéresse sont les tables \texttt{osm\_nodes} et \texttt{osm\_relations}. Ces tables contiennent les données de tout les bâtiments. Ceux-ci ne contiennent généralement qu'une \Gls{géométrie}, une structure de donnée contenant plusieurs points et formant un polygone. Parfois seulement, des \Gls{tags} peuvent être ajoutés. Ces tags peuvent contenir des informations sur la hauteur du bâtiment, sa couleur, son matériau, etc.

La \href{https://wiki.openstreetmap.org/wiki/Simple_3D_Buildings}{documentation OpenStreetMap}\footnote{https://wiki.openstreetmap.org/wiki/Simple\_3D\_Buildings} nous permet d'avoir la liste complète des tags existants et nous intéressant concernant les bâtiments.

Pour pouvoir récupérer toutes ces informations, j'utilise la requête SQL suivante :

\newpage
\begin{verbatim}
SELECT st_asbinary(geom),
    tags -> building,
    tags -> height,
    tags -> building:levels,
    tags -> building:min_level,
    tags -> building:colour,
    tags -> building:material,
    tags -> building:part,
    tags -> roof:shape,
    tags -> roof:levels,
    tags -> roof:height,
    tags -> roof:color,
    tags -> roof:material,
    tags -> roof:angle,
    tags -> roof:direction
FROM osm_ways
WHERE (tags ? building or tags ? building:part) and
    st_intersects(geom, st_makeenvelope(%1$s, %2$s, %3$s, %4$s, 4326))
UNION
SELECT st_asbinary(geom),
    tags -> building,
    tags -> height,
    tags -> building:levels,
    tags -> building:min_level,
    tags -> building:colour,
    tags -> building:material,
    tags -> building:part,
    tags -> roof:shape,
    tags -> roof:levels,
    tags -> roof:height,
    tags -> roof:color,
    tags -> roof:material,
    tags -> roof:angle,
    tags -> roof:direction
FROM osm_relations
WHERE (tags ? building or tags ? building:part) and
    st_intersects(geom, st_makeenvelope(%1$s, %2$s, %3$s, %4$s, 4326));
\end{verbatim}

Grâce à cette requête, je récupère toutes les informations nécessaires pour définir et générer les bâtiments en fichiers glTF. \texttt{\%1\$s, \%2\$s, \%3\$s, \%4\$s, et \%5\$s} sont des espaces réservés qui seront remplacés par les coordonnées de la zone à charger lors de l'exécution de la requête.

\newpage
\subsection{Données générées}

Les données générées sont stockées dans les tables \texttt{td\_subtrees} et \texttt{td\_tile\_gltf}. La première contient toutes les informations nécessaires à la définition d'un Subtree. La seconde contient les fichiers glTF des tuiles. Ces tables sont définies comme suit :

\begin{verbatim}
CREATE TABLE td_subtrees
(
    morton_index bigint,
    level        integer,
    binary_file  bytea,
    UNIQUE (morton_index, level)
);

CREATE TABLE td_tile_gltf
(
    x           bigint,
    y           bigint,
    level       integer,
    gltf_binary bytea,
    UNIQUE (x, y, level)
);
\end{verbatim}